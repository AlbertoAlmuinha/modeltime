% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modeltime-forecast.R
\name{modeltime_forecast}
\alias{modeltime_forecast}
\title{Forecast future data}
\usage{
modeltime_forecast(
  object,
  new_data = NULL,
  h = NULL,
  conf_interval = 0.8,
  actual_data = NULL,
  ...
)
}
\arguments{
\item{object}{A Modeltime Table that has been calibrated with \code{\link[=modeltime_calibrate]{modeltime_calibrate()}}}

\item{new_data}{A \code{tibble} containing future information to forecast.}

\item{h}{The forecast horizon (can be used instead of \code{new_data} for
time series with no exogenous regressors). Always extends the calibration data.}

\item{conf_interval}{An estimated confidence interval based on the in-sample residuals}

\item{actual_data}{Data that is combined with the output tibble and given an \code{.key = "actual"}}

\item{...}{Additional arguments passed to \code{\link[=future_frame]{future_frame()}} for use with the \code{h} forecast horizon}
}
\value{
A tibble with predictions and time-stamp data. For ease of plotting and calculations,
the column names are transformed to:
\itemize{
\item \code{.key}: Values labeled either "prediction" or "actual"
\item \code{.index}: The timestamp index.
\item \code{.value}: The value being forecasted.
\item \code{.conf_lo}: The lower limit of the confidence interval.
\item \code{.conf_hi}: The upper limit of the confidence interval.
}

Additional descriptive columns are included:
\itemize{
\item \code{.model_id}: Model ID from the Modeltime Table
\item \code{.model_desc}: Model Description from the Modeltime Table
}
}
\description{
The goal of \code{modeltime_forecast()} is to simplify the process of
forecasting future data.
}
\details{
The key parameters are (controlled by \code{new_data} or \code{h}) and
combining with existing data (controlled by \code{actual_data}) in preparation
for visualization with \code{\link[=plot_modeltime_forecast]{plot_modeltime_forecast()}}.

\strong{Specifying New Data or Horizon (h)}

When forecasting without external regressors, meaning that features are dependent on the
date feature alone, you can specify future data using:
\enumerate{
\item \verb{h = "3 years" or "36 months" or 36}: This is dependent on the \code{.calibration_data}.
All forecasts are extended after the calibration data.
\item \code{new_data}: A future tibble with date column extending the trained dates.
See \code{\link[=future_frame]{future_frame()}} for creating future tibbles.
}

\strong{Actual Data}

This is reference data that contains the true values of the time-stamp data.
It helps in visualizing the performance of the forecast vs the actual data.

\emph{Confidence Interval Estimation}

Confidence intervals are estimated based on the normal estimation of the testing errors (out of sample).

The confidence interval can be adjusted with the \code{conf_interval} parameter. An
80\% confidence interval estimates a normal (gaussian distribution) that assumes that
80\% of the future data will fall within the upper and lower confidence limits.

The confidence interval is \emph{mean-adjusted}, meaning that if the mean of the residuals
is non-zero, the confidence interval is adjusted to widen the interval to capture
the difference in means.
}
\examples{
library(tidyverse)
library(lubridate)
library(timetk)
library(parsnip)
library(rsample)

# Data
m750 <- m4_monthly \%>\% filter(id == "M750")

# Split Data 80/20
splits <- initial_time_split(m750, prop = 0.9)

# --- MODELS ---

# Model 1: auto_arima ----
model_fit_no_boost <- arima_reg() \%>\%
    set_engine(engine = "auto_arima") \%>\%
    fit(value ~ date, data = training(splits))

# Model 2: arima_boost ----
model_fit_boosted <- arima_boost(
    min_n = 2,
    learn_rate = 0.015
) \%>\%
    set_engine(engine = "auto_arima_xgboost") \%>\%
    fit(value ~ date + as.numeric(date) + month(date, label = TRUE),
        data = training(splits))

# ---- MODELTIME TABLE ----

models_tbl <- modeltime_table(
    model_fit_no_boost,
    model_fit_boosted
)

# ---- CALIBRATE ----

calibration_tbl <- models_tbl \%>\%
    modeltime_calibrate(new_data = testing(splits))

# ---- ACCURACY ----

calibration_tbl \%>\%
    modeltime_accuracy()

# ---- FORECAST ----

calibration_tbl \%>\%
    modeltime_forecast(
        new_data    = testing(splits),
        actual_data = m750
    )

}
