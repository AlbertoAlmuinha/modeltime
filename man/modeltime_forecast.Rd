% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modeltime-forecast.R
\name{modeltime_forecast}
\alias{modeltime_forecast}
\title{Forecast future data}
\usage{
modeltime_forecast(
  object,
  new_data = NULL,
  h = NULL,
  conf_interval = 0.8,
  actual_data = NULL,
  ...
)
}
\arguments{
\item{object}{A fitted model object that is either (1) a workflow that has been fit by \code{\link[=fit.workflow]{fit.workflow()}} or
(2) a parsnip model that has been fit using \code{\link[=fit.model_spec]{fit.model_spec()}}}

\item{new_data}{A \code{tibble} containing future information to forecast.}

\item{h}{The forecast horizon (can be used instead of \code{new_data} for
time series with no exogenous regressors).}

\item{conf_interval}{An estimated confidence interval based on the in-sample residuals}

\item{actual_data}{Data that is combined with the output tibble and given an \code{.key = "actual"}}

\item{...}{Additional arguments passed to \code{\link[=future_frame]{future_frame()}} for use with the \code{h} forecast horizon}
}
\value{
A tibble with predictions and time-stamp data. For ease of plotting and calculations,
the column names are transformed to:
\itemize{
\item \code{.key}: Values labeled either "prediction" or "actual"
\item \code{.index}: The timestamp index.
\item \code{.value}: The value being forecasted.
\item \code{.conf_lo}: The lower limit of the confidence interval.
\item \code{.conf_hi}: The upper limit of the confidence interval.
}
}
\description{
This is a wrapper for \code{predict()} that is simplifies forecasting
future data from a fitted \code{workflow} (trained workflow) or \code{model_fit} (trained parsnip model).
}
\details{
The goal of \code{modeltime_forecast()} is to simplify the process of
forecasting future data (controlled by \code{new_data} or \code{h}) and
combining with existing data (controlled by \code{actual_data}).

\strong{Specifying Future Data}

When forecasting without external regressors, meaning that features are dependent on the
date feature alone, you can specify future data using:
\enumerate{
\item \verb{h = "3 years" or "36 months" or 36}:
\item \verb{new_data = tibble with date column extending the trained dates}
}

\strong{Interfaces}

There are 2 interfaces:
\enumerate{
\item Fitted Parsnip Model
\item Fitted Workflow
}

\emph{Interface 1: Fitted Parsnip Model (\code{model_fit} class)}
\itemize{
\item Currently, only the \strong{formula format} is supported (e.g. \code{model_fit <- model_spec \%>\% fit(y ~ date)}).
\item New data and actual data are processed according to the formula (e.g. \code{fit(log(y) ~ date)} will
result in a log transformation applied to future data and new data)
}

\emph{Interface 2: Fitted Workflow (\code{workflow} with \verb{$trained = TRUE})}
\itemize{
\item Currently, only the \strong{recipe format} is supported. However, \code{tidymodels/workflows} Issue #34
will correct issues with indicators, which prevents the \strong{formula format}.
\item Transformations are applied according to the \code{recipe}. New data is forged with \code{hardhat::forge}.
}

\emph{Confidence Interval Estimation}

Confidence intervals are estimated based on the normal estimation of the testing errors (out of sample).
The confidence interval can be adjusted with the \code{conf_interval} parameter. An
80\% confidence interval estimates a normal (gaussian distribution) that assumes that
80\% of the future data will fall within the upper and lower confidence limits.

The confidence interval is mean adjusted, meaning that if the mean of the residuals
is non-zero, the confidence interval is adjusted to widen the interval.
}
\examples{
library(tidyverse)
library(lubridate)
library(timetk)
library(parsnip)
library(rsample)

# Data
m750 <- m4_monthly \%>\% filter(id == "M750")

# Split Data 80/20
splits <- initial_time_split(m750, prop = 0.9)

# --- MODELS ---

# Model 1: auto_arima ----
model_fit_no_boost <- arima_reg() \%>\%
    set_engine(engine = "auto_arima") \%>\%
    fit(value ~ date, data = training(splits))

# Model 2: arima_boost ----
model_fit_boosted <- arima_boost(
    min_n = 2,
    learn_rate = 0.015
) \%>\%
    set_engine(engine = "auto_arima_xgboost") \%>\%
    fit(value ~ date + as.numeric(date) + month(date, label = TRUE),
        data = training(splits))

# ---- MODELTIME TABLE ----

models_tbl <- modeltime_table(
    model_fit_no_boost,
    model_fit_boosted
)

# ---- ACCURACY ----

models_tbl \%>\%
    modeltime_calibrate(new_data = testing(splits)) \%>\%
    modeltime_accuracy()

# ---- FORECAST ----

models_tbl \%>\%
    modeltime_calibrate(new_data = testing(splits)) \%>\%
    modeltime_forecast(
        new_data    = testing(splits),
        actual_data = m750
    )

}
