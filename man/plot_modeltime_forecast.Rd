% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modeltime-forecast-plot.R
\name{plot_modeltime_forecast}
\alias{plot_modeltime_forecast}
\title{Interactive Forecast Visualization}
\usage{
plot_modeltime_forecast(
  .data,
  .include_conf_interval = TRUE,
  .title = "Forecast Plot",
  .x_lab = "",
  .y_lab = "",
  .color_lab = "Legend",
  .interactive = TRUE,
  .plotly_slider = FALSE,
  ...
)
}
\arguments{
\item{.data}{A \code{tibble} or \code{data.frame} with '.id', '.index', and .value' columns}

\item{.include_conf_interval}{Logical. Whether or not to include the confidence interval as a ribbon.}

\item{.title}{Title for the plot}

\item{.x_lab}{X-axis label for the plot}

\item{.y_lab}{Y-axis label for the plot}

\item{.color_lab}{Legend label if a \code{color_var} is used.}

\item{.interactive}{Returns either a static (\code{ggplot2}) visualization or an interactive (\code{plotly}) visualization}

\item{.plotly_slider}{If TRUE, returns a plotly date range slider.}

\item{...}{Additional arguments passed to \code{\link[timetk:plot_time_series]{timetk::plot_time_series()}}.}
}
\value{
A static \code{ggplot2} plot or an interactive \code{plotly} plot containing a forecast
}
\description{
This is a wrapper for \code{\link[=plot_time_series]{plot_time_series()}} that generates an interactive (\code{plotly}) or static
(\code{ggplot2}) plot with the forecasted data.
}
\examples{
library(dplyr)
library(parsnip)
library(rsample)
library(timetk)
library(modeltime)

# Data
m750 <- m4_monthly \%>\% filter(id == "M750")
m750

# Split Data 80/20
splits <- initial_time_split(m750, prop = 0.8)

# Model Spec
model_spec <- arima_reg(
        period                   = 12,
        non_seasonal_ar          = 3,
        non_seasonal_differences = 1,
        non_seasonal_ma          = 3,
        seasonal_ar              = 1,
        seasonal_differences     = 0,
        seasonal_ma              = 1
    ) \%>\%
    set_engine("arima")

# Fit Spec
model_fit <- model_spec \%>\%
    fit(log(value) ~ date, data = training(splits))

# --- VISUALIZE FORECAST ---

# Combining forecast with actual values
model_fit \%>\%
    modeltime_forecast(h = "3 years", actual_data = training(splits)) \%>\%
    mutate(.value = exp(.value)) \%>\%
    plot_modeltime_forecast(.interactive = FALSE)

}
