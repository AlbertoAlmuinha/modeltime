% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modeltime-calibrate.R
\name{modeltime_calibrate}
\alias{modeltime_calibrate}
\title{Preparation for forecasting}
\usage{
modeltime_calibrate(object, new_data = NULL, quiet = TRUE, ...)
}
\arguments{
\item{object}{A fitted model object that is either:
\enumerate{
\item A workflow that has been fit by \code{\link[=fit.workflow]{fit.workflow()}} or
\item A parsnip model that has been fit using \code{\link[=fit.model_spec]{fit.model_spec()}}
\item A modeltime table that has been created using \code{\link[=modeltime_table]{modeltime_table()}}
}}

\item{new_data}{A test data set \code{tibble} containing future information (timestamps and actual values).}

\item{quiet}{Hide errors (\code{TRUE}, the default), or display them as they occur?}

\item{...}{Additional arguments passed to \code{\link[=modeltime_forecast]{modeltime_forecast()}}.}
}
\value{
A \code{mdl_time_tbl} with \code{.calibration_data} added
}
\description{
Preparation for forecasting
}
\details{
The results of calibration are used for:
\itemize{
\item \strong{Forecast Confidence Interval Estimation}: The out of sample residual data is used to calculate the
confidence interval. Refer to \code{\link[=modeltime_forecast]{modeltime_forecast()}}.
\item \strong{Accuracy Calculations:} The out of sample actual and prediction values are used to calculate
performance metrics. Refer to \code{\link[=modeltime_accuracy]{modeltime_accuracy()}}
}

The calibration steps include:
\enumerate{
\item If not a Modeltime Table, objects are converted to Modeltime Tables internally
\item Two Columns are added:
}
\itemize{
\item \code{.type}: Indicates the sample type. Only "Test" is currently available.
\item \code{.calibration_data}: Contains a tibble with Actual Values, Predictions and Residuals
calculated from \code{new_data} (Test Data)
}
}
\examples{
library(tidyverse)
library(lubridate)
library(timetk)
library(parsnip)
library(rsample)

# Data
m750 <- m4_monthly \%>\% filter(id == "M750")

# Split Data 80/20
splits <- initial_time_split(m750, prop = 0.9)

# --- MODELS ---

# Model 1: auto_arima ----
model_fit_no_boost <- arima_reg() \%>\%
    set_engine(engine = "auto_arima") \%>\%
    fit(value ~ date, data = training(splits))

# Model 2: arima_boost ----
model_fit_boosted <- arima_boost(
    min_n = 2,
    learn_rate = 0.015
) \%>\%
    set_engine(engine = "auto_arima_xgboost") \%>\%
    fit(value ~ date + as.numeric(date) + month(date, label = TRUE),
        data = training(splits))

# ---- MODELTIME TABLE ----

models_tbl <- modeltime_table(
    model_fit_no_boost,
    model_fit_boosted
)

# ---- ACCURACY ----

models_tbl \%>\%
    modeltime_calibrate(new_data = testing(splits)) \%>\%
    modeltime_accuracy()

# ---- FORECAST ----

models_tbl \%>\%
    modeltime_calibrate(new_data = testing(splits)) \%>\%
    modeltime_forecast(
        new_data    = testing(splits),
        actual_data = m750
    )


}
