% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modeltime-recursive_panel.R
\name{recursive_panel}
\alias{recursive_panel}
\title{Create a Recursive Time Series Model from a Parsnip or Workflow Regression Model}
\usage{
recursive_panel(object, transform, train_tail, ...)
}
\arguments{
\item{object}{An object of \code{model_fit} or a fitted \code{workflow} class}

\item{transform}{A transformation performed on new_data after
each step of recursive algorithm. It can be an object of types:
\itemize{
\item \strong{Method 1, \code{function}:} Must have one argument \code{data} and and you
must group by the variable \code{id}, perform the transformations and
finally ungroup. (see examples)
}}

\item{train_tail}{A tibble with tail by group of training data set.
In most cases it'll be required to create some variables
based on dependent variable. You can use the function
modeltime::panel_data() (see examples)}

\item{...}{Not currently used.}
}
\value{
An object with added \code{recursive_panel} class
}
\description{
Create a Recursive Time Series Model from a Parsnip or Workflow Regression Model
}
\details{
Recursive model can be used if some of the features used for training
is based of dependent variable we already are trying to forecast.
Typically, among these features we can find lags (e.g. created with \code{tk_augment_lags()})
or variables crated with sliding window.

When producing forecast, the following steps are performed:
\enumerate{
\item Computing forecast for first row of new data.
The first row cannot contain NA in any required column.
\item Filling i-th place of the dependent variable column with
already computed forecast.
\item Computing missing features for next step, based on
already calculated prediction. These features are computed
with on a tibble object made from binded \code{train_tail} (i.e. tail of
training data set) and \code{new_data} (which is an argument of predict function).
\item Jumping into point 2., and repeating rest of steps till the for-loop is ended.
}
}
\examples{
# Libraries & Setup ----

library(modeltime)
library(tidymodels)
library(tidyverse)
library(lubridate)
library(timetk)
library(slider)

# METHOD 1: TRANSFORM FUNCTION ----

m4_monthly

FORECAST_HORIZON <- 24

m4_extended <- m4_monthly \%>\%
    group_by(id) \%>\%
    future_frame(
        .length_out = FORECAST_HORIZON,
        .bind_data  = TRUE
    ) \%>\%
    ungroup()

lag_transformer <- function(data){
    data \%>\%
        group_by(id) \%>\%
        # Lags
        tk_augment_lags(value, .lags = 1:24) \%>\%
        ungroup()
}

m4_lags <- m4_extended \%>\%
    lag_transformer()

train_data <- m4_lags \%>\%
    filter(!is.na(value)) \%>\%
    drop_na()

future_data <- m4_lags \%>\%
    filter(is.na(value))


model_fit_lm_recursive <- linear_reg() \%>\%
    set_engine("lm") \%>\%
    fit(value ~ ., data = train_data) \%>\%
    recursive_panel(
        transform  = lag_transformer,
        train_tail = modeltime::panel_tail(train_data, id, FORECAST_HORIZON)
    )

modeltime_table(model_fit_lm_recursive) \%>\%
    modeltime_forecast(new_data = future_data,
                       actual_data = m4_monthly,
                       keep_data = TRUE) \%>\%
    group_by(id) \%>\%
    plot_modeltime_forecast(
        .interactive = FALSE,
        .conf_interval_show = FALSE
    )


}
