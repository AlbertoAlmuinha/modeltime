% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/modeltime-recursive.R
\name{recursive}
\alias{recursive}
\title{Create a recursive time series model from arbitrary parsnip regression model}
\usage{
recursive(object, transform, train_tail, ...)
}
\arguments{
\item{object}{An object of model_fit class}

\item{transform}{A transformation performed on new_data after
each step of recursive algorithm. It can be an object of types:
\itemize{
\item prepped \code{recipe}: The recipe generates lagged or sliding features
\item \code{function} with two argument: \code{temp_new_data} and \code{slice_idx}
}}

\item{train_tail}{A tibble with tail of training data set.
In most cases it'll be required to create some variables
based on dependent variable.}

\item{...}{Not currently used.}
}
\value{
An object with added \code{recursive} class
}
\description{
Create a recursive time series model from arbitrary parsnip regression model
}
\details{
Recursive model can be used if some of the features used for training
is based of dependent variable we already are trying to forecast.
Typically, among these features we can find lags (e.g. created with \code{step_lag()})
or variables crated with sliding window.

When producing forecast, the following steps are performed:
\enumerate{
\item Computing forecast for first row of new data.
The first row cannot contain NA in any required column.
\item Filling i-th place of the dependent variable column with
already computed forecast.
\item Computing missing features for next step, based on
already calculated prediction. These features are computed
with on a tibble object made from binded \code{train_tail} (i.e. tail of
training data set) and \code{new_data} (which is an argument of predict function).
\item Jumping into point 2., and repeating rest of steps till the for-loop is ended.
}
}
\examples{
library(tidymodels)
library(modeltime)
library(slider)
library(tidyverse)


# METHOD 1: RECIPE METHOD ----
# - Add lags or sliding features

dax_stock <- as_tibble(EuStockMarkets) \%>\%
   select(DAX) \%>\%
   bind_rows(tibble(DAX = rep(NA, 30))) # Adding new data

recipe_dax_stock <- recipe(DAX ~ ., data = dax_stock) \%>\%
   step_lag(all_outcomes(), lag = 1:10) \%>\%
   prep()

dax_stock_m <- juice(recipe_dax_stock)

dax_stock_m

# SPLIT INTO TRAIN / FORECAST DATA ----
# - Divide set into training data and future forecast

train_data <- dax_stock_m \%>\%
   filter(!is.na(DAX)) \%>\%
   na.omit()

new_data <- dax_stock_m \%>\%
   filter(is.na(DAX))

# RECURSIVE MODELING ----

model_linear <- linear_reg() \%>\%
   set_engine("lm") \%>\%
   fit(DAX ~ ., data = train_data)

recursive_linear <- model_linear \%>\%
   recursive(
       transform  = recipe_dax_stock,
       train_tail = tail(train_data, 10)
   )

pred <- recursive_linear \%>\%
   predict(new_data)

pred

# METHOD 2: TRANSFORM METHOD  ----
# - Using function as transform

dax_stock <-
  as_tibble(EuStockMarkets) \%>\%
  select(DAX) \%>\%
  bind_rows(tibble(DAX = rep(NA, 30))) # Adding new data

# Transform Function can be used to make complex lagged transformations
#  beyond the available recipes
transform_fun <- function(data, slice_idx){
   data \%>\%
       mutate(moving_sum = lag(slide_dbl(
           DAX, .f = mean, .before = 4L
       ), 1))
 }

# Make Full Data
dax_stock_m <- dax_stock \%>\%
  mutate(moving_sum = lag(slider::slide_dbl(
       DAX, .f = mean, .before = 4L
  ), 1))

dax_stock_m

# Get Train Data
train_data <- dax_stock_m \%>\%
  filter(!is.na(DAX)) \%>\%
  na.omit()

# Get Future Data
new_data <- dax_stock_m \%>\%
  filter(is.na(DAX))

# Make Fitted Model
model_linear <- linear_reg() \%>\%
   set_engine("lm") \%>\%
   fit(DAX ~ ., data = train_data)

# Convert to Recursive Model
recursive_linear <- model_linear \%>\%
   recursive(transform_fun,
             train_tail = tail(train_data, 10))

# Make predictions
pred <- recursive_linear \%>\%
   predict(new_data)

pred

}
