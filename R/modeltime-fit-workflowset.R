# MODELTIME FIT WORKFLOWSET ----

#' Fit a `workflowset` object to one or multiple time series
#'
#' This is a wrapper for `fit()` that takes a
#' `workflowset` object and fits each model on one or multiple
#' time series either sequentially or in parallel.
#'
#' @param workflowset A workflow_set object, generated with the workflowsets::workflow_set function.
#' @param series A `tibble` that contains data to fit the models.
#' @param control An object used to modify the fitting process.
#'
#' @seealso
#' [control_workflowset()]
#'
#' @return
#' A Modeltime Table containing one or more fitted models.
#' @export
modeltime_fit_workflowset <- function(workflowset, series, control = control_workflowset()){

    if (!inherits(workflowset, "workflow_set")){
        rlang::abort("workflowset argument must be a `workflow_set` object generated by workflowsets::workflow_set function.")
    }

    .models <- workflowset %>% split(.$wflow_id)

    if (control$cores > 1){
        message("Starting parallel backend...")
        cl <- parallel::makeCluster(control$cores)
        doSNOW::registerDoSNOW(cl)
    } else {
        foreach::registerDoSEQ()
    }

    get_operator <- function(allow_par = TRUE) {
        is_par <- foreach::getDoParWorkers() > 1

        cond <- allow_par && is_par
        if (cond) {
            res <- foreach::`%dopar%`
        } else {
            res <- foreach::`%do%`
        }
        return(res)
    }

    `%op%` <- get_operator(allow_par = control$allow_par)

    progress <- function(n) {
        message(stringr::str_glue("Fitting model id {n} - {.models[[n]] %>% dplyr::pull(1)}"))
    }

    opts <- list(progress=progress)

    models <- foreach::foreach(this_model = seq_len(length(.models)),
                         .options.snow = if (control$verbose) opts else NULL, #Parallel Printing
                         .inorder = FALSE,
                         .packages = control$packages) %op% {

                            if (control$verbose){
                                message(stringr::str_glue("Fitting model id {this_model} - {.models[[this_model]] %>% dplyr::pull(1)}"))
                            }

                            model<- .models[[this_model]] %>%
                                     dplyr::pull(2) %>%
                                     purrr::pluck(1, 'workflow', 1) %>%
                                     parsnip::fit(series)

                            return(model)

                         }

    if (control$cores > 1) {doParallel::stopImplicitCluster()
        parallel::stopCluster(cl)
        message("Finishing parallel backend")}

    modeltime_tbl <- models %>%
                     purrr::map(modeltime_table) %>%
                     purrr::reduce(combine_modeltime_tables)

    message("Done. Have a good day.")

    return(modeltime_tbl)

}



# Control Workflowset
#
#' Control aspects of the modeltime_fit_workflowset process.
#'
#' @param allow_par Logical to allow parallel computation
#' @param cores Number of cores for computation
#' @param packages Packages that the user wants to send to the workers during parallelization.
#' @param verbose Logical to control printing.
#'
#' @seealso
#' [modeltime_fit_workflowset()]
#'
#' @return
#' A List with the information.
#' @export
control_workflowset <- function(allow_par = TRUE,
                          cores = 1,
                          packages = c("modeltime", "parsnip", "dplyr", "stats",
                                       "lubridate", "tidymodels", "timetk"),
                          verbose = FALSE) {
    # add options for  seeds per resample

    val_class_and_single(verbose, "logical", "control_refit()")
    val_class_and_single(allow_par, "logical", "control_refit()")
    val_class_and_single(cores, "numeric", "control_refit()")

    class_cores <- check_class_integer(cores)

    load_namespace(packages, full_load = packages)

    if (class_cores == F) {rlang::abort("Argument 'cores' should be a single integer value in `control_refit()`")}

    res <- list(allow_par = allow_par,
                cores = cores,
                packages = packages,
                verbose = verbose)

    class(res) <- c("control_workflowset")
    res
}

#' @export
print.control_workflowset <- function(x, ...) {
    cat("workflowset control object\n")
    invisible(x)
}


