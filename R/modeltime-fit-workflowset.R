# MODELTIME FIT WORKFLOWSET ----

#' Fit a `workflowset` object to one or multiple time series
#'
#' This is a wrapper for `fit()` that takes a
#' `workflowset` object and fits each model on one or multiple
#' time series either sequentially or in parallel.
#'
#' @param object A workflow_set object, generated with the workflowsets::workflow_set function.
#' @param data A `tibble` that contains data to fit the models.
#' @param control An object used to modify the fitting process.
#' @param ... Not currently used
#'
#' @seealso
#' [control_workflowset()]
#'
#' @examples
#' library(tidymodels)
#' library(modeltime)
#' library(workflowsets)
#' library(tidyverse)
#' library(lubridate)
#' library(timetk)
#'
#' data_set <- m4_monthly
#'
#' # SETUP WORKFLOWSETS
#'
#' rec1 <- recipe(value ~ date + id, data_set) %>%
#'     step_mutate(date_num = as.numeric(date)) %>%
#'     step_mutate(month_lbl = lubridate::month(date, label = TRUE)) %>%
#'     step_dummy(all_nominal(), one_hot = TRUE)
#'
#' mod1 <- linear_reg() %>% set_engine("lm")
#'
#' mod2 <- prophet_reg() %>% set_engine("prophet")
#'
#' wfsets <- workflowsets::workflow_set(
#'     preproc = list(rec1 = rec1),
#'     models  = list(
#'         mod1 = mod1,
#'         mod2 = mod2
#'     ),
#'     cross   = TRUE
#' )
#'
#' # FIT WORKFLOWSETS
#' # - Returns a Modeltime Table with fitted workflowsets
#'
#' wfsets %>% modeltime_fit_workflowset(data_set)
#'
#' @return
#' A Modeltime Table containing one or more fitted models.
#' @export
modeltime_fit_workflowset <- function(object, data, ..., control = control_workflowset()) {

    if (!inherits(object, "workflow_set")){
        rlang::abort("object argument must be a `workflow_set` object generated by workflowsets::workflow_set function.")
    }

    # Parallel or Sequential
    if ((control$cores > 1) && control$allow_par) {
        models <- modeltime_fit_workflowset_parallel(object, data = data, control = control, ...)
    } else {
        models <- modeltime_fit_workflowset_sequential(object, data = data, control = control, ...)
    }

    names(models) <- NULL

    modeltime_tbl <- models %>% as_modeltime_table()

    return(modeltime_tbl)

}

modeltime_fit_workflowset_sequential <- function(object, data, control, ...) {

    .models  <- object %>% split(.$wflow_id)
    safe_fit <- purrr::safely(parsnip::fit, otherwise = NULL, quiet = FALSE)

    models <- .models %>%
        purrr::imap(
            .f = function(obj, i) {

                if (control$verbose) message(stringr::str_glue("Fitting Model: {i}"))

                mod <- obj %>%
                    dplyr::pull(2) %>%
                    purrr::pluck(1, 'workflow', 1)

                safe_fit(mod, data = data) %>%
                    purrr::pluck("result")
            }
        )

    return(models)


}

modeltime_fit_workflowset_parallel <- function(object, data, control, ...) {

    is_par_setup <- foreach::getDoParWorkers() > 1

    .models <- object %>% split(.$wflow_id)

    # If parallel processing is not set up, set up parallel backend
    if ((control$cores > 1) && control$allow_par && (!is_par_setup)){
        if (control$verbose) message(stringr::str_glue("Starting parallel backend with {control$cores} clusters (cores)..."))
        cl <- parallel::makeCluster(control$cores)
        doParallel::registerDoParallel(cl)
        parallel::clusterCall(cl, function(x) .libPaths(x), .libPaths())
    } else if (!is_par_setup) {
        # Run sequentially if parallel is not set up, cores == 1 or allow_par == FALSE
        if (control$verbose) message(stringr::str_glue("Running sequential backend. If parallel was intended, set `allow_par = TRUE` and `cores > 1`."))
        foreach::registerDoSEQ()
    } else {
        # Parallel was set up externally by user - Do nothing.
        if (control$verbose) message(stringr::str_glue("Using existing parallel backend with {foreach::getDoParWorkers()} clusters (cores)..."))
    }

    get_operator <- function(allow_par = TRUE) {
        is_par <- foreach::getDoParWorkers() > 1

        cond <- allow_par && is_par
        if (cond) {
            res <- foreach::`%dopar%`
        } else {
            res <- foreach::`%do%`
        }
        return(res)
    }

    `%op%` <- get_operator(allow_par = control$allow_par)

    # progress <- function(n) {
    #     message(stringr::str_glue("Fitting Model: {n}"))
    # }
    #
    # opts <- list(progress=progress)

    safe_fit <- purrr::safely(parsnip::fit, otherwise = NULL, quiet = FALSE)

    models <- foreach::foreach(
        this_model          = .models,
        # nm                  = object$wflow_id,
        # .options.snow       = if (control$verbose) opts else NULL, #Parallel Printing
        .inorder            = TRUE,
        .packages           = control$packages
    ) %op% {

        mod <- this_model %>%
            dplyr::pull(2) %>%
            purrr::pluck(1, 'workflow', 1) %>%
            safe_fit(data) %>%
            purrr::pluck("result")

        return(mod)

    }

    # Finish Parallel Backend. Close clusters if we set up internally.
    if ((control$cores > 1) && control$allow_par && (!is_par_setup)) {
        # We set up parallel processing internally. We should close.
        doParallel::stopImplicitCluster()
        parallel::stopCluster(cl)
        foreach::registerDoSEQ()
        if (control$verbose) {
            message("Finishing parallel backend. Closing clusters.")

        }
    } else if ((control$cores > 1) && control$allow_par) {
        if (control$verbose) {
            message("Finishing parallel backend. Clusters are remaining open. Close clusters by running: `foreach::registerDoSEQ()`")
        }
    } else {
        if (control$verbose) {
            message("Finishing sequential backend.")
        }
    }

    return(models)

}

# Control Workflowset
#
#' Control aspects of the `modeltime_fit_workflowset()` process.
#'
#' @inheritParams control_refit
#'
#'
#' @return
#' A List with the control settings.
#'
#' @seealso
#' [modeltime_fit_workflowset()]
#'
#' @export
control_workflowset <- function(verbose = FALSE,
                                allow_par = FALSE,
                                cores = -1,
                                packages = NULL) {

    ret <- control_modeltime_objects(
        verbose   = verbose,
        allow_par = allow_par,
        cores     = cores,
        packages  = packages
    )

    class(ret) <- c("control_workflowset")

    return(ret)

}

#' @export
print.control_workflowset <- function(x, ...) {
    cat("workflowset control object\n")
    invisible(x)
}


